---
title: "Run_RHESSysPreprocess"
author: "William Burke"
date: "2/13/2020"
output: pdf_document
urlcolor: blue
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  eval = FALSE
)
```


## Overview
This is an example workflow/script showing how the RHESSysPreprocess.R function should be run.

1. Install the RHESSysPreprocessing package.
2. Copy this script, and edit where indicated.
3. Run the RHESSysPreprocess.R function.
4. The funciton will produce:
    * Worldfile
    * Flowtable
    * Header (optional)

For additional directions on generating inputs for the Regional HydroEcologic Simulation System (RHESSys) see the [RHESSys Wiki](https://github.com/RHESSys/RHESSys/wiki)

## Install & Load Package
If you haven't already installed the package, do so now (shown here using the devtools package), and then load the package.
```{r setup, eval = FALSE}
#library(devtools)
#devtools::install_github("RHESSys/RHESSysPreprocessing")
library(RHESSysPreprocessing)
```

## Filepaths
This script uses relative filepaths. This means that it will look for folders and files relative to your current working directory. If needed, set your current working directory to the folder of your project:
```{r, eval = FALSE}
#setwd("~/Documents/MyProject")
getwd()
```
The "~" is a shorthand method of navigating to your "home" user directory - typically the folder named for your username.

## Template
The worldfile template is the guiding document that outlines how your worldfile will be built. The template argument should point to the name and location of your template. See the [template](https://github.com/RHESSys/RHESSys/wiki/Template) section of the RHESSys Wiki for more information.
```{r}
#template = "/templates/example.template"
template = "worldfiles/templates/template_hpb.txt"

```

## Spatial Data
You will need provide the spatial data inputs being referenced in your template. There is now only one supported method of spatial data input, which is using raster data - spatial data in any raster format supported by R [GDAL](https://gdal.org/drivers/raster/index.html), read in from a folder. Previously there was support for using GRASS GIS, if you used that method previously, output those maps to raster formats (geotiff, ascii, etc.). See the Wiki section on [Spatial Input Requirements](https://github.com/RHESSys/RHESSys/wiki/Spatial-Input-Requirements) for more information.

To use spatial data from a folder of rasters:

1. Input data should have the same projections, extents, and cell sizes.
2. Set `type` to "raster"
```{r}
type = "raster"
```
3. Set `typepars` to the path of the folder containing your rasters
```{r}
#typepars = "spatial_data"
typepars = "spatial_data"

```

## Name
Set the name and path for all function outputs. Suffixes of .world, .flow, and .hdr will be appended to the worldfile, flowtable, and (optional) header files respectively.
```{r}
#this is just name that will appear before .world
#this spits out .world and .flow in getwd(), so will move to right location
name = "hpb"

```

## Overwrite
TRUE/FALSE if an existing worldfile and flowtable should be overwritten.
```{r}
overwrite = FALSE
```

## Streams
Streams map to be used in creation of the flowtable - this is just the name of the map, to be found via the method indicated with `type`, at the path indicated by `typepars`
```{r}
#streams = "my_watershed_streams"
streams = "hpb_streams1"
```

## Optional Flowtable Spatial Data
These maps are optional inputs in flowtable creation
```{r}
# roads = "roads_map"
# impervious = "impervious_map"
# roofs = "roofs_map"
```

## Header
TRUE/FALSE to produce a header file. Header file will be have same name(and location) set by "name", with the ".hdr" suffix.
```{r}
header = FALSE
```

Parallelization
---------------
Current (v7.1+, Dec 2018 and on) develop branch RHESSys is hillslope paralleized and requires a flowtable that is compatible. This makes a few key changes relative to the old flowtable generation, highlighted in the R help documentation for RHESSysPreprocess and CreateFlownet.
```{r}
parallel = TRUE
```

The `make_stream` argument defines the distance from an existing stream that the outlet of a hillslope can be set to be a stream. Since all hilslopes must have stream outlets, if a hillslope outlet exists outside of the distance threshold set by "make_stream",an error will occur and indicae the problem hillslope/outlet patch of that hillslope. This typically occurs as an artifact of how watershed analysis is done, and hillslopes are created, which sometimes results in fragmented or very
small/skinny hillslopes, far away from streams. `make_stream` can be set to any positive value, or TRUE to always set hillslope outlets to streams.
Default is 4, which is meant to roughly account for the errors/aritifacts that might occur from GIS, without including any
extreme outlying hillslopes
```{r}
make_stream = 4
```

## Run RHESSysPreprocess
Finally, run the function.  Depending on size, it may take a few mintues (or more).
```{r}
# RHESSysPreprocess(
#   template = template,
#   name = name,
#   type = type,
#   typepars = typepars,
#   streams = streams,
#   overwrite = overwrite,
#   header = header)

RHESSysPreprocess(
  template,
  name,
  map_dir = typepars,
  typepars = NULL,
  streams = streams,
  overwrite = FALSE,
  roads = NULL,
  impervious = NULL,
  roofs = NULL,
  header = FALSE,
  meta = FALSE,
  asprules = NULL,
  unique_strata_ID = TRUE,
  seq_patch_IDs = FALSE,
  output_patch_map = FALSE,
  fire_grid_out = FALSE,
  parallel = TRUE,
  make_stream = 4,
  skip_hillslope_check = TRUE,
  convert_aspect = TRUE,
  wrapper = TRUE
)



```

##DWH working on NAs in maps 

```{r}
library(terra)

getwd()

#read in rasters and check for visual NA issues
watershed <- rast("spatial_data/hpb_watershed.tiff")
plot((watershed), main = "watershed map")
plot(is.na(watershed), main = "NA locations in watershed map")


#basin and patches with NA
subbasin <- rast("spatial_data/hpb_basins_5000.tiff")
plot((subbasin), main = "subbasin map")
plot(is.na(subbasin), main = "NA locations in subbasin map")

# patch <- rast("spatial_data/hpb_patchcl.tiff")
patch <- rast("spatial_data/hpb_patches_basin1000.tiff")
plot((patch), main = "patch map")
plot(is.na(patch), main = "NA locations in patch map")


#check that extent and everything is the same, should return trues
compareGeom(subbasin, watershed)
compareGeom(patch, watershed)


#visualize NAs better
na_mask <- is.na(patch)
plot(na_mask, col = c("transparent", "red"), legend = FALSE, main = "NA Locations")

zoom(patch)


```
trying some fixes here after checks

```{r}

# Create a mask of the world extent
world_mask <- !is.na(watershed)

# Check where patch and subbasin maps have NA *within* world extent
patch_na <- is.na(patch) & world_mask
subbasin_na <- is.na(subbasin) & world_mask

# Count NA cells
sum(values(patch_na), na.rm = TRUE)
sum(values(subbasin_na), na.rm = TRUE)

#This gets to confirming what RHESSYs said in that there's NAs within the watershed area


summary(values(patch))
summary(values(subbasin))
summary(values(watershed))


```

try filling NAs

```{r}
###for patches 
# patch_filled <- focal(patch, w = matrix(1, 3, 3), fun = function(x, ...) {
#   if (is.na(x[5])) {
#     # Replace center cell with nearest non-NA value
#     non_na <- x[!is.na(x)]
#     if (length(non_na) > 0) {
#       return(non_na[1])  # You could use median(non_na) or mode(non_na) if preferred
#     } else {
#       return(NA)
#     }
#   } else {
#     return(x[5])
#   }
# }, na.policy = "only", fillvalue = NA)
# 
# #did it work 
# sum(is.na(values(patch_filled)))
# 
# 
# #another try
# patch_filled2 <- terra::approximate(patch, method = "linear")


##try clunky 999 fill and see what RHESSys does
patch[patch_na] <- 999
sum(is.na(values(patch)))

subbasin[subbasin_na] <- 999


writeRaster(subbasin, "spatial_data/hpb_basins_5000_fill.tiff", overwrite = T)
writeRaster(patch, "spatial_data/hpb_patches_basin1000_fill.tiff", overwrite = T)


```



## Troubleshooting
If you encounter errors or are unable to create your RHESSys inputs, first consult the [RHESSys Wiki](https://github.com/RHESSys/RHESSys/wiki) and the R help documentation via `?RHESSysPreprocessing::RHESSysPreprocess`.  If possible try testing with different inputs. If it seems to be a bug, you can create an issue on the [RHESSysPreprocessing GitHub](https://github.com/RHESSys/RHESSysPreprocessing).
